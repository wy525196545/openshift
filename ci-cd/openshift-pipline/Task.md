# Configuring a Task
A Task definition supports the following fields:
- Required:
  - apiVersion - Specifies the API version. For example, tekton.dev/v1beta1.
  - kind - Identifies this resource object as a Task object.
  - metadata - Specifies metadata that uniquely identifies the Task resource object. For example, a name.
  - spec - Specifies the configuration information for this Task resource object.
  - steps - Specifies one or more container images to run in the Task.
- Optional:
  - description - An informative description of the Task.
  - params - Specifies execution parameters for the Task.
  - workspaces - Specifies paths to volumes required by the Task.
  - results - Specifies the names under which Tasks write execution results.
  - volumes - Specifies one or more volumes that will be available to the Steps in the Task.
  - stepTemplate - Specifies a Container step definition to use as the basis for all Steps in the Task.
  - sidecars - Specifies Sidecar containers to run alongside the Steps in the Task.
### Defining Steps
A Step is a reference to a container image that executes a specific tool on a specific input and produces a specific output. To add Steps to a Task you define a steps field (required) containing a list of desired Steps. The order in which the Steps appear in this list is the order in which they will execute.

- The following requirements apply to each container image referenced in a steps field:
  - The container image must abide by the container contract.
  - Each container image runs to completion or until the first failure occurs.
  - The CPU, memory, and ephemeral storage resource requests set on Steps will be adjusted to comply with any LimitRanges present in the Namespace. In addition, Kubernetes determines a pod’s effective resource requests and limits by summing the requests and limits for all its containers, even though Tekton runs Steps sequentially. For more detail, see Compute Resources in Tekton.

#### Reserved directories
There are several directories that all Tasks run by Tekton will treat as special
- /workspace - This directory is where resources and workspaces are mounted. Paths to these are available to Task authors via variable substitution
/tekton - This directory is used for Tekton specific functionality:
- /tekton/results is where results are written to. The path is available to Task authors via $(results.name.path)
There are other subfolders which are implementation details of Tekton and users should not rely on their specific behavior as it may change in the future

#### Running scripts within Steps
A step can specify a script field, which contains the body of a script. That script is invoked as if it were stored inside the container image, and any args are passed directly to it.

Note: If the script field is present, the step cannot also contain a command field.

Scripts that do not start with a shebang line will have the following default preamble prepended:

```
#!/bin/sh
set -e
```
You can override this default preamble by prepending a shebang that specifies the desired parser. This parser must be present within that Step's container image.

- The example below executes a Bash script:
```
steps:
  - image: ubuntu # contains bash
    script: |
      #!/usr/bin/env bash
      echo "Hello from Bash!"      
```
- The example below executes a Python script:
```
steps:
  - image: python # contains python
    script: |
      #!/usr/bin/env python3
      print("Hello from Python!")   
```
- The example below executes a Node script:
```
steps:
  - image: node # contains node
    script: |
      #!/usr/bin/env node
      console.log("Hello from Node!")    
```
- You can execute scripts directly in the workspace:
```
steps:
  - image: ubuntu
    script: |
      #!/usr/bin/env bash
      /workspace/my-script.sh  # provided by an input resource    
```
- You can also execute scripts within the container image:
```
steps:
  - image: my-image # contains /bin/my-binary
    script: |
      #!/usr/bin/env bash
      /bin/my-binary      
```
##### Windows scripts 
Scripts in tasks that will eventually run on windows nodes need a custom shebang line, so that Tekton knows how to run the script. The format of the shebang line is:
```
#!win <interpreter command> <args>
```
- Unlike linux, we need to specify how to interpret the script file which is generated by Tekton. The example below shows how to execute a powershell script:
```
steps:
  - image: mcr.microsoft.com/windows/servercore:1809
    script: |
      #!win powershell.exe -File
      echo 'Hello from PowerShell'  
```
- Microsoft provide powershell images, which contain Powershell Core (which is slightly different from powershell found in standard windows images). The example below shows how to use these images:

```
steps:
  - image: mcr.microsoft.com/powershell:nanoserver
    script: |
      #!win pwsh.exe -File
      echo 'Hello from PowerShell Core'     
```
- As can be seen the command is different. The windows shebang can be used for any interpreter, as long as it exists in the image and can interpret commands from a file. The example below executes a Python script:
```
 steps:
  - image: python
    script: |
      #!win python
      print("Hello from Python!")   
```
Note that other than the #!win shebang the example is identical to the earlier linux example.
- Finally, if no interpreter is specified on the #!win line then the script will be treated as a windows .cmd file which will be excecuted. The example below shows this:
```
 steps:
  - image: mcr.microsoft.com/powershell:lts-nanoserver-1809
    script: |
      #!win
      echo Hello from the default cmd file  
```
#### Specifying a timeout

A Step can specify a timeout field. If the Step execution time exceeds the specified timeout, the Step kills its running process and any subsequent Steps in the TaskRun will not be executed. The TaskRun is placed into a Failed condition. An accompanying log describing which Step timed out is written as the Failed condition’s message.

The timeout specification follows the duration format as specified in the Go time package (e.g. 1s or 1ms).
- The example Step below is supposed to sleep for 60 seconds but will be canceled by the specified 5 second timeout.

```
steps:
  - name: sleep-then-timeout
    image: ubuntu
    script: |
      #!/usr/bin/env bash
      echo "I am supposed to sleep for 60 seconds!"
      sleep 60      
    timeout: 5s
```
#### Specifying onError for a step
When a step in a task results in a failure, the rest of the steps in the task are skipped and the taskRun is declared a failure. If you would like to ignore such step errors and continue executing the rest of the steps in the task, you can specify onError for such a step.

onError can be set to either continue or stopAndFail as part of the step definition. If onError is set to stopAndFail, the entrypoint sets the original failed exit code of the script in the container terminated state. A step with onError set to continue does not fail the taskRun and continues executing the rest of the steps in a task.

- To ignore a step error, set onError to continue:
```
steps:
  - image: docker.io/library/golang:latest
    name: ignore-unit-test-failure
    onError: continue
    script: |
            go test .
```
#### Accessing Step’s exitCode in subsequent Steps
- A step can access the exit code of any previous step by reading the file pointed to by the exitCode path variable:
```
cat $(steps.step-<step-name>.exitCode.path)
```
- The exitCode of a step without any name can be referenced using:
```
cat $(steps.step-unnamed-<step-index>.exitCode.path)
```
#### Produce a task result with onError
- When a step is set to ignore the step error and if that step is able to initialize a result file before failing, that result is made available to its consumer task.
```
steps:
  - name: ignore-failure-and-produce-a-result
    onError: continue
    image: busybox
    script: |
      echo -n 123 | tee $(results.result1.path)
      exit 1      
```
The task consuming the result using the result reference $(tasks.task1.results.result1) in a pipeline will be able to access the result and run with the resolved value.
```
steps:
  - name: ignore-failure-and-produce-a-result
    onError: continue
    image: busybox
    script: |
      echo -n 123 | tee $(results.result1.path)
      exit 1
      echo -n 456 | tee $(results.result2.path)   
```
### Specifying Parameters
You can specify parameters, such as compilation flags or artifact names, that you want to supply to the Task at execution time. Parameters are passed to the Task from its corresponding TaskRun.













































